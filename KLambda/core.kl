"Copyright (c) 2015, Mark Tarver

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
1. Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.
3. The name of Mark Tarver may not be used to endorse or promote products
   derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY Mark Tarver ''AS IS'' AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL Mark Tarver BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."

(defun shen.shen->kl (V13104 V13105) (compile (lambda X (shen.<define> X)) (cons V13104 V13105) (lambda X (shen.shen-syntax-error V13104 X))))

(defun shen.shen-syntax-error (V13112 V13113) (cond ((cons? V13113) (simple-error (cn "syntax error in " (shen.app V13112 (cn " here:

 " (shen.app (shen.next-50 50 (hd V13113)) "
" shen.a)) shen.a)))) (true (simple-error (cn "syntax error in " (shen.app V13112 "
" shen.a))))))

(defun shen.<define> (V13115) (let YaccParse (let Parse_shen.<name> (shen.<name> V13115) (if (not (= (fail) Parse_shen.<name>)) (let Parse_shen.<signature> (shen.<signature> Parse_shen.<name>) (if (not (= (fail) Parse_shen.<signature>)) (let Parse_shen.<rules> (shen.<rules> Parse_shen.<signature>) (if (not (= (fail) Parse_shen.<rules>)) (shen.pair (hd Parse_shen.<rules>) (shen.compile_to_machine_code (shen.hdtl Parse_shen.<name>) (shen.hdtl Parse_shen.<rules>))) (fail))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_shen.<name> (shen.<name> V13115) (if (not (= (fail) Parse_shen.<name>)) (let Parse_shen.<rules> (shen.<rules> Parse_shen.<name>) (if (not (= (fail) Parse_shen.<rules>)) (shen.pair (hd Parse_shen.<rules>) (shen.compile_to_machine_code (shen.hdtl Parse_shen.<name>) (shen.hdtl Parse_shen.<rules>))) (fail))) (fail))) YaccParse)))

(defun shen.<name> (V13117) (if (cons? (hd V13117)) (let Parse_X (hd (hd V13117)) (shen.pair (hd (shen.pair (tl (hd V13117)) (shen.hdtl V13117))) (if (and (symbol? Parse_X) (not (shen.sysfunc? Parse_X))) Parse_X (simple-error (shen.app Parse_X " is not a legitimate function name.
" shen.a))))) (fail)))

(defun shen.sysfunc? (V13119) (element? V13119 (get (intern "shen") shen.external-symbols (value *property-vector*))))

(defun shen.<signature> (V13121) (if (and (cons? (hd V13121)) (= { (hd (hd V13121)))) (let Parse_shen.<signature-help> (shen.<signature-help> (shen.pair (tl (hd V13121)) (shen.hdtl V13121))) (if (not (= (fail) Parse_shen.<signature-help>)) (if (and (cons? (hd Parse_shen.<signature-help>)) (= } (hd (hd Parse_shen.<signature-help>)))) (shen.pair (hd (shen.pair (tl (hd Parse_shen.<signature-help>)) (shen.hdtl Parse_shen.<signature-help>))) (shen.demodulate (shen.curry-type (shen.hdtl Parse_shen.<signature-help>)))) (fail)) (fail))) (fail)))

(defun shen.curry-type (V13123) (cond ((and (cons? V13123) (and (cons? (tl V13123)) (and (= --> (hd (tl V13123))) (and (cons? (tl (tl V13123))) (and (cons? (tl (tl (tl V13123)))) (= --> (hd (tl (tl (tl V13123)))))))))) (shen.curry-type (cons (hd V13123) (cons --> (cons (tl (tl V13123)) ()))))) ((and (cons? V13123) (and (cons? (tl V13123)) (and (= * (hd (tl V13123))) (and (cons? (tl (tl V13123))) (and (cons? (tl (tl (tl V13123)))) (= * (hd (tl (tl (tl V13123)))))))))) (shen.curry-type (cons (hd V13123) (cons * (cons (tl (tl V13123)) ()))))) ((cons? V13123) (map (lambda Z (shen.curry-type Z)) V13123)) (true V13123)))

(defun shen.<signature-help> (V13125) (let YaccParse (if (cons? (hd V13125)) (let Parse_X (hd (hd V13125)) (let Parse_shen.<signature-help> (shen.<signature-help> (shen.pair (tl (hd V13125)) (shen.hdtl V13125))) (if (not (= (fail) Parse_shen.<signature-help>)) (if (not (element? Parse_X (cons { (cons } ())))) (shen.pair (hd Parse_shen.<signature-help>) (cons Parse_X (shen.hdtl Parse_shen.<signature-help>))) (fail)) (fail)))) (fail)) (if (= YaccParse (fail)) (let Parse_<e> (<e> V13125) (if (not (= (fail) Parse_<e>)) (shen.pair (hd Parse_<e>) ()) (fail))) YaccParse)))

(defun shen.<rules> (V13127) (let YaccParse (let Parse_shen.<rule> (shen.<rule> V13127) (if (not (= (fail) Parse_shen.<rule>)) (let Parse_shen.<rules> (shen.<rules> Parse_shen.<rule>) (if (not (= (fail) Parse_shen.<rules>)) (shen.pair (hd Parse_shen.<rules>) (cons (shen.linearise (shen.hdtl Parse_shen.<rule>)) (shen.hdtl Parse_shen.<rules>))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_shen.<rule> (shen.<rule> V13127) (if (not (= (fail) Parse_shen.<rule>)) (shen.pair (hd Parse_shen.<rule>) (cons (shen.linearise (shen.hdtl Parse_shen.<rule>)) ())) (fail))) YaccParse)))

(defun shen.<rule> (V13129) (let YaccParse (let Parse_shen.<patterns> (shen.<patterns> V13129) (if (not (= (fail) Parse_shen.<patterns>)) (if (and (cons? (hd Parse_shen.<patterns>)) (= -> (hd (hd Parse_shen.<patterns>)))) (let Parse_shen.<action> (shen.<action> (shen.pair (tl (hd Parse_shen.<patterns>)) (shen.hdtl Parse_shen.<patterns>))) (if (not (= (fail) Parse_shen.<action>)) (if (and (cons? (hd Parse_shen.<action>)) (= where (hd (hd Parse_shen.<action>)))) (let Parse_shen.<guard> (shen.<guard> (shen.pair (tl (hd Parse_shen.<action>)) (shen.hdtl Parse_shen.<action>))) (if (not (= (fail) Parse_shen.<guard>)) (shen.pair (hd Parse_shen.<guard>) (cons (shen.hdtl Parse_shen.<patterns>) (cons (cons where (cons (shen.hdtl Parse_shen.<guard>) (cons (shen.hdtl Parse_shen.<action>) ()))) ()))) (fail))) (fail)) (fail))) (fail)) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<patterns> (shen.<patterns> V13129) (if (not (= (fail) Parse_shen.<patterns>)) (if (and (cons? (hd Parse_shen.<patterns>)) (= -> (hd (hd Parse_shen.<patterns>)))) (let Parse_shen.<action> (shen.<action> (shen.pair (tl (hd Parse_shen.<patterns>)) (shen.hdtl Parse_shen.<patterns>))) (if (not (= (fail) Parse_shen.<action>)) (shen.pair (hd Parse_shen.<action>) (cons (shen.hdtl Parse_shen.<patterns>) (cons (shen.hdtl Parse_shen.<action>) ()))) (fail))) (fail)) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<patterns> (shen.<patterns> V13129) (if (not (= (fail) Parse_shen.<patterns>)) (if (and (cons? (hd Parse_shen.<patterns>)) (= <- (hd (hd Parse_shen.<patterns>)))) (let Parse_shen.<action> (shen.<action> (shen.pair (tl (hd Parse_shen.<patterns>)) (shen.hdtl Parse_shen.<patterns>))) (if (not (= (fail) Parse_shen.<action>)) (if (and (cons? (hd Parse_shen.<action>)) (= where (hd (hd Parse_shen.<action>)))) (let Parse_shen.<guard> (shen.<guard> (shen.pair (tl (hd Parse_shen.<action>)) (shen.hdtl Parse_shen.<action>))) (if (not (= (fail) Parse_shen.<guard>)) (shen.pair (hd Parse_shen.<guard>) (cons (shen.hdtl Parse_shen.<patterns>) (cons (cons where (cons (shen.hdtl Parse_shen.<guard>) (cons (cons shen.choicepoint! (cons (shen.hdtl Parse_shen.<action>) ())) ()))) ()))) (fail))) (fail)) (fail))) (fail)) (fail))) (if (= YaccParse (fail)) (let Parse_shen.<patterns> (shen.<patterns> V13129) (if (not (= (fail) Parse_shen.<patterns>)) (if (and (cons? (hd Parse_shen.<patterns>)) (= <- (hd (hd Parse_shen.<patterns>)))) (let Parse_shen.<action> (shen.<action> (shen.pair (tl (hd Parse_shen.<patterns>)) (shen.hdtl Parse_shen.<patterns>))) (if (not (= (fail) Parse_shen.<action>)) (shen.pair (hd Parse_shen.<action>) (cons (shen.hdtl Parse_shen.<patterns>) (cons (cons shen.choicepoint! (cons (shen.hdtl Parse_shen.<action>) ())) ()))) (fail))) (fail)) (fail))) YaccParse)) YaccParse)) YaccParse)))

(defun shen.fail_if (V13132 V13133) (if (V13132 V13133) (fail) V13133))

(defun shen.succeeds? (V13139) (cond ((= V13139 (fail)) false) (true true)))

(defun shen.<patterns> (V13141) (let YaccParse (let Parse_shen.<pattern> (shen.<pattern> V13141) (if (not (= (fail) Parse_shen.<pattern>)) (let Parse_shen.<patterns> (shen.<patterns> Parse_shen.<pattern>) (if (not (= (fail) Parse_shen.<patterns>)) (shen.pair (hd Parse_shen.<patterns>) (cons (shen.hdtl Parse_shen.<pattern>) (shen.hdtl Parse_shen.<patterns>))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_<e> (<e> V13141) (if (not (= (fail) Parse_<e>)) (shen.pair (hd Parse_<e>) ()) (fail))) YaccParse)))

(defun shen.<pattern> (V13148) (let YaccParse (if (and (cons? (hd V13148)) (cons? (hd (hd V13148)))) (if (and (cons? (hd (shen.pair (hd (hd V13148)) (hd (tl V13148))))) (= @p (hd (hd (shen.pair (hd (hd V13148)) (hd (tl V13148))))))) (let Parse_shen.<pattern1> (shen.<pattern1> (shen.pair (tl (hd (shen.pair (hd (hd V13148)) (hd (tl V13148))))) (shen.hdtl (shen.pair (hd (hd V13148)) (hd (tl V13148)))))) (if (not (= (fail) Parse_shen.<pattern1>)) (let Parse_shen.<pattern2> (shen.<pattern2> Parse_shen.<pattern1>) (if (not (= (fail) Parse_shen.<pattern2>)) (shen.pair (hd (shen.pair (tl (hd V13148)) (hd (tl V13148)))) (cons @p (cons (shen.hdtl Parse_shen.<pattern1>) (cons (shen.hdtl Parse_shen.<pattern2>) ())))) (fail))) (fail))) (fail)) (fail)) (if (= YaccParse (fail)) (let YaccParse (if (and (cons? (hd V13148)) (cons? (hd (hd V13148)))) (if (and (cons? (hd (shen.pair (hd (hd V13148)) (hd (tl V13148))))) (= cons (hd (hd (shen.pair (hd (hd V13148)) (hd (tl V13148))))))) (let Parse_shen.<pattern1> (shen.<pattern1> (shen.pair (tl (hd (shen.pair (hd (hd V13148)) (hd (tl V13148))))) (shen.hdtl (shen.pair (hd (hd V13148)) (hd (tl V13148)))))) (if (not (= (fail) Parse_shen.<pattern1>)) (let Parse_shen.<pattern2> (shen.<pattern2> Parse_shen.<pattern1>) (if (not (= (fail) Parse_shen.<pattern2>)) (shen.pair (hd (shen.pair (tl (hd V13148)) (hd (tl V13148)))) (cons cons (cons (shen.hdtl Parse_shen.<pattern1>) (cons (shen.hdtl Parse_shen.<pattern2>) ())))) (fail))) (fail))) (fail)) (fail)) (if (= YaccParse (fail)) (let YaccParse (if (and (cons? (hd V13148)) (cons? (hd (hd V13148)))) (if (and (cons? (hd (shen.pair (hd (hd V13148)) (hd (tl V13148))))) (= @v (hd (hd (shen.pair (hd (hd V13148)) (hd (tl V13148))))))) (let Parse_shen.<pattern1> (shen.<pattern1> (shen.pair (tl (hd (shen.pair (hd (hd V13148)) (hd (tl V13148))))) (shen.hdtl (shen.pair (hd (hd V13148)) (hd (tl V13148)))))) (if (not (= (fail) Parse_shen.<pattern1>)) (let Parse_shen.<pattern2> (shen.<pattern2> Parse_shen.<pattern1>) (if (not (= (fail) Parse_shen.<pattern2>)) (shen.pair (hd (shen.pair (tl (hd V13148)) (hd (tl V13148)))) (cons @v (cons (shen.hdtl Parse_shen.<pattern1>) (cons (shen.hdtl Parse_shen.<pattern2>) ())))) (fail))) (fail))) (fail)) (fail)) (if (= YaccParse (fail)) (let YaccParse (if (and (cons? (hd V13148)) (cons? (hd (hd V13148)))) (if (and (cons? (hd (shen.pair (hd (hd V13148)) (hd (tl V13148))))) (= @s (hd (hd (shen.pair (hd (hd V13148)) (hd (tl V13148))))))) (let Parse_shen.<pattern1> (shen.<pattern1> (shen.pair (tl (hd (shen.pair (hd (hd V13148)) (hd (tl V13148))))) (shen.hdtl (shen.pair (hd (hd V13148)) (hd (tl V13148)))))) (if (not (= (fail) Parse_shen.<pattern1>)) (let Parse_shen.<pattern2> (shen.<pattern2> Parse_shen.<pattern1>) (if (not (= (fail) Parse_shen.<pattern2>)) (shen.pair (hd (shen.pair (tl (hd V13148)) (hd (tl V13148)))) (cons @s (cons (shen.hdtl Parse_shen.<pattern1>) (cons (shen.hdtl Parse_shen.<pattern2>) ())))) (fail))) (fail))) (fail)) (fail)) (if (= YaccParse (fail)) (let YaccParse (if (and (cons? (hd V13148)) (cons? (hd (hd V13148)))) (if (and (cons? (hd (shen.pair (hd (hd V13148)) (hd (tl V13148))))) (= vector (hd (hd (shen.pair (hd (hd V13148)) (hd (tl V13148))))))) (if (and (cons? (hd (shen.pair (tl (hd (shen.pair (hd (hd V13148)) (hd (tl V13148))))) (shen.hdtl (shen.pair (hd (hd V13148)) (hd (tl V13148))))))) (= 0 (hd (hd (shen.pair (tl (hd (shen.pair (hd (hd V13148)) (hd (tl V13148))))) (shen.hdtl (shen.pair (hd (hd V13148)) (hd (tl V13148))))))))) (shen.pair (hd (shen.pair (tl (hd V13148)) (hd (tl V13148)))) (cons vector (cons 0 ()))) (fail)) (fail)) (fail)) (if (= YaccParse (fail)) (let YaccParse (if (cons? (hd V13148)) (let Parse_X (hd (hd V13148)) (if (cons? Parse_X) (shen.pair (hd (shen.pair (tl (hd V13148)) (shen.hdtl V13148))) (shen.constructor-error Parse_X)) (fail))) (fail)) (if (= YaccParse (fail)) (let Parse_shen.<simple_pattern> (shen.<simple_pattern> V13148) (if (not (= (fail) Parse_shen.<simple_pattern>)) (shen.pair (hd Parse_shen.<simple_pattern>) (shen.hdtl Parse_shen.<simple_pattern>)) (fail))) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)))

(defun shen.constructor-error (V13150) (simple-error (shen.app V13150 " is not a legitimate constructor
" shen.a)))

(defun shen.<simple_pattern> (V13152) (let YaccParse (if (cons? (hd V13152)) (let Parse_X (hd (hd V13152)) (if (= Parse_X _) (shen.pair (hd (shen.pair (tl (hd V13152)) (shen.hdtl V13152))) (gensym Parse_Y)) (fail))) (fail)) (if (= YaccParse (fail)) (if (cons? (hd V13152)) (let Parse_X (hd (hd V13152)) (if (not (element? Parse_X (cons -> (cons <- ())))) (shen.pair (hd (shen.pair (tl (hd V13152)) (shen.hdtl V13152))) Parse_X) (fail))) (fail)) YaccParse)))

(defun shen.<pattern1> (V13154) (let Parse_shen.<pattern> (shen.<pattern> V13154) (if (not (= (fail) Parse_shen.<pattern>)) (shen.pair (hd Parse_shen.<pattern>) (shen.hdtl Parse_shen.<pattern>)) (fail))))

(defun shen.<pattern2> (V13156) (let Parse_shen.<pattern> (shen.<pattern> V13156) (if (not (= (fail) Parse_shen.<pattern>)) (shen.pair (hd Parse_shen.<pattern>) (shen.hdtl Parse_shen.<pattern>)) (fail))))

(defun shen.<action> (V13158) (if (cons? (hd V13158)) (let Parse_X (hd (hd V13158)) (shen.pair (hd (shen.pair (tl (hd V13158)) (shen.hdtl V13158))) Parse_X)) (fail)))

(defun shen.<guard> (V13160) (if (cons? (hd V13160)) (let Parse_X (hd (hd V13160)) (shen.pair (hd (shen.pair (tl (hd V13160)) (shen.hdtl V13160))) Parse_X)) (fail)))

(defun shen.compile_to_machine_code (V13163 V13164) (let Lambda+ (shen.compile_to_lambda+ V13163 V13164) (let KL (shen.compile_to_kl V13163 Lambda+) (let Record (shen.record-source V13163 KL) KL))))

(defun shen.record-source (V13169 V13170) (cond ((value shen.*installing-kl*) shen.skip) (true (put V13169 shen.source V13170 (value *property-vector*)))))

(defun shen.compile_to_lambda+ (V13173 V13174) (let Arity (shen.aritycheck V13173 V13174) (let UpDateSymbolTable (shen.update-symbol-table V13173 Arity) (let Free (map (lambda Rule (shen.free_variable_check V13173 Rule)) V13174) (let Variables (shen.parameters Arity) (let Strip (map (lambda X (shen.strip-protect X)) V13174) (let Abstractions (map (lambda X (shen.abstract_rule X)) Strip) (let Applications (map (lambda X (shen.application_build Variables X)) Abstractions) (cons Variables (cons Applications ()))))))))))

(defun shen.update-symbol-table (V13177 V13178) (set shen.*symbol-table* (shen.update-symbol-table-h V13177 V13178 (value shen.*symbol-table*) ())))

(defun shen.update-symbol-table-h (V13186 V13187 V13188 V13189) (cond ((= () V13188) (let NewEntry (cons V13186 (eval-kl (shen.lambda-form V13186 V13187))) (cons NewEntry V13189))) ((and (cons? V13188) (and (cons? (hd V13188)) (= (hd (hd V13188)) V13186))) (let ChangedEntry (cons (hd (hd V13188)) (eval-kl (shen.lambda-form (hd (hd V13188)) V13187))) (append (tl V13188) (cons ChangedEntry V13189)))) ((cons? V13188) (shen.update-symbol-table-h V13186 V13187 (tl V13188) (cons (hd V13188) V13189))) (true (shen.f_error shen.update-symbol-table-h))))

(defun shen.free_variable_check (V13192 V13193) (cond ((and (cons? V13193) (and (cons? (tl V13193)) (= () (tl (tl V13193))))) (let Bound (shen.extract_vars (hd V13193)) (let Free (shen.extract_free_vars Bound (hd (tl V13193))) (shen.free_variable_warnings V13192 Free)))) (true (shen.f_error shen.free_variable_check))))

(defun shen.extract_vars (V13195) (cond ((variable? V13195) (cons V13195 ())) ((cons? V13195) (union (shen.extract_vars (hd V13195)) (shen.extract_vars (tl V13195)))) (true ())))

(defun shen.extract_free_vars (V13207 V13208) (cond ((and (cons? V13208) (and (cons? (tl V13208)) (and (= () (tl (tl V13208))) (= (hd V13208) protect)))) ()) ((and (variable? V13208) (not (element? V13208 V13207))) (cons V13208 ())) ((and (cons? V13208) (and (= lambda (hd V13208)) (and (cons? (tl V13208)) (and (cons? (tl (tl V13208))) (= () (tl (tl (tl V13208)))))))) (shen.extract_free_vars (cons (hd (tl V13208)) V13207) (hd (tl (tl V13208))))) ((and (cons? V13208) (and (= let (hd V13208)) (and (cons? (tl V13208)) (and (cons? (tl (tl V13208))) (and (cons? (tl (tl (tl V13208)))) (= () (tl (tl (tl (tl V13208)))))))))) (union (shen.extract_free_vars V13207 (hd (tl (tl V13208)))) (shen.extract_free_vars (cons (hd (tl V13208)) V13207) (hd (tl (tl (tl V13208))))))) ((cons? V13208) (union (shen.extract_free_vars V13207 (hd V13208)) (shen.extract_free_vars V13207 (tl V13208)))) (true ())))

(defun shen.free_variable_warnings (V13213 V13214) (cond ((= () V13214) _) (true (simple-error (cn "error: the following variables are free in " (shen.app V13213 (cn ": " (shen.app (shen.list_variables V13214) "" shen.a)) shen.a))))))

(defun shen.list_variables (V13216) (cond ((and (cons? V13216) (= () (tl V13216))) (cn (str (hd V13216)) ".")) ((cons? V13216) (cn (str (hd V13216)) (cn ", " (shen.list_variables (tl V13216))))) (true (shen.f_error shen.list_variables))))

(defun shen.strip-protect (V13218) (cond ((and (cons? V13218) (and (cons? (tl V13218)) (and (= () (tl (tl V13218))) (= (hd V13218) protect)))) (shen.strip-protect (hd (tl V13218)))) ((cons? V13218) (map (lambda Z (shen.strip-protect Z)) V13218)) (true V13218)))

(defun shen.linearise (V13220) (cond ((and (cons? V13220) (and (cons? (tl V13220)) (= () (tl (tl V13220))))) (shen.linearise_help (shen.flatten (hd V13220)) (hd V13220) (hd (tl V13220)))) (true (shen.f_error shen.linearise))))

(defun shen.flatten (V13222) (cond ((= () V13222) ()) ((cons? V13222) (append (shen.flatten (hd V13222)) (shen.flatten (tl V13222)))) (true (cons V13222 ()))))

(defun shen.linearise_help (V13226 V13227 V13228) (cond ((= () V13226) (cons V13227 (cons V13228 ()))) ((cons? V13226) (if (and (variable? (hd V13226)) (element? (hd V13226) (tl V13226))) (let Var (gensym (hd V13226)) (let NewAction (cons where (cons (cons = (cons (hd V13226) (cons Var ()))) (cons V13228 ()))) (let NewPatts (shen.linearise_X (hd V13226) Var V13227) (shen.linearise_help (tl V13226) NewPatts NewAction)))) (shen.linearise_help (tl V13226) V13227 V13228))) (true (shen.f_error shen.linearise_help))))

(defun shen.linearise_X (V13241 V13242 V13243) (cond ((= V13243 V13241) V13242) ((cons? V13243) (let L (shen.linearise_X V13241 V13242 (hd V13243)) (if (= L (hd V13243)) (cons (hd V13243) (shen.linearise_X V13241 V13242 (tl V13243))) (cons L (tl V13243))))) (true V13243)))

(defun shen.aritycheck (V13246 V13247) (cond ((and (cons? V13247) (and (cons? (hd V13247)) (and (cons? (tl (hd V13247))) (and (= () (tl (tl (hd V13247)))) (= () (tl V13247)))))) (do (shen.aritycheck-action (hd (tl (hd V13247)))) (shen.aritycheck-name V13246 (arity V13246) (length (hd (hd V13247)))))) ((and (cons? V13247) (and (cons? (hd V13247)) (and (cons? (tl (hd V13247))) (and (= () (tl (tl (hd V13247)))) (and (cons? (tl V13247)) (and (cons? (hd (tl V13247))) (and (cons? (tl (hd (tl V13247)))) (= () (tl (tl (hd (tl V13247)))))))))))) (if (= (length (hd (hd V13247))) (length (hd (hd (tl V13247))))) (do (shen.aritycheck-action (hd (tl (hd V13247)))) (shen.aritycheck V13246 (tl V13247))) (simple-error (cn "arity error in " (shen.app V13246 "
" shen.a))))) (true (shen.f_error shen.aritycheck))))

(defun shen.aritycheck-name (V13260 V13261 V13262) (cond ((= -1 V13261) V13262) ((= V13262 V13261) V13262) (true (do (shen.prhush (cn "
warning: changing the arity of " (shen.app V13260 " can cause errors.
" shen.a)) (stoutput)) V13262))))

(defun shen.aritycheck-action (V13268) (cond ((cons? V13268) (do (shen.aah (hd V13268) (tl V13268)) (map (lambda Y (shen.aritycheck-action Y)) V13268))) (true shen.skip)))

(defun shen.aah (V13271 V13272) (let Arity (arity V13271) (let Len (length V13272) (if (and (> Arity -1) (> Len Arity)) (shen.prhush (cn "warning: " (shen.app V13271 (cn " might not like " (shen.app Len (cn " argument" (shen.app (if (> Len 1) "s" "") ".
" shen.a)) shen.a)) shen.a)) (stoutput)) shen.skip))))

(defun shen.abstract_rule (V13274) (cond ((and (cons? V13274) (and (cons? (tl V13274)) (= () (tl (tl V13274))))) (shen.abstraction_build (hd V13274) (hd (tl V13274)))) (true (shen.f_error shen.abstract_rule))))

(defun shen.abstraction_build (V13277 V13278) (cond ((= () V13277) V13278) ((cons? V13277) (cons /. (cons (hd V13277) (cons (shen.abstraction_build (tl V13277) V13278) ())))) (true (shen.f_error shen.abstraction_build))))

(defun shen.parameters (V13280) (cond ((= 0 V13280) ()) (true (cons (gensym V) (shen.parameters (- V13280 1))))))

(defun shen.application_build (V13283 V13284) (cond ((= () V13283) V13284) ((cons? V13283) (shen.application_build (tl V13283) (cons V13284 (cons (hd V13283) ())))) (true (shen.f_error shen.application_build))))

(defun shen.compile_to_kl (V13287 V13288) (cond ((and (cons? V13288) (and (cons? (tl V13288)) (= () (tl (tl V13288))))) (let Arity (shen.store-arity V13287 (length (hd V13288))) (let Reduce (map (lambda X (shen.reduce X)) (hd (tl V13288))) (let CondExpression (shen.cond-expression V13287 (hd V13288) Reduce) (let TypeTable (if (value shen.*optimise*) (shen.typextable (shen.get-type V13287) (hd V13288)) shen.skip) (let TypedCondExpression (if (value shen.*optimise*) (shen.assign-types (hd V13288) TypeTable CondExpression) CondExpression) (let KL (cons defun (cons V13287 (cons (hd V13288) (cons TypedCondExpression ())))) KL))))))) (true (shen.f_error shen.compile_to_kl))))

(defun shen.get-type (V13294) (cond ((cons? V13294) shen.skip) (true (let FType (assoc V13294 (value shen.*signedfuncs*)) (if (empty? FType) shen.skip (tl FType))))))

(defun shen.typextable (V13305 V13306) (cond ((and (cons? V13305) (and (cons? (tl V13305)) (and (= --> (hd (tl V13305))) (and (cons? (tl (tl V13305))) (and (= () (tl (tl (tl V13305)))) (cons? V13306)))))) (if (variable? (hd V13305)) (shen.typextable (hd (tl (tl V13305))) (tl V13306)) (cons (cons (hd V13306) (hd V13305)) (shen.typextable (hd (tl (tl V13305))) (tl V13306))))) (true ())))

(defun shen.assign-types (V13310 V13311 V13312) (cond ((and (cons? V13312) (and (= let (hd V13312)) (and (cons? (tl V13312)) (and (cons? (tl (tl V13312))) (and (cons? (tl (tl (tl V13312)))) (= () (tl (tl (tl (tl V13312)))))))))) (cons let (cons (hd (tl V13312)) (cons (shen.assign-types V13310 V13311 (hd (tl (tl V13312)))) (cons (shen.assign-types (cons (hd (tl V13312)) V13310) V13311 (hd (tl (tl (tl V13312))))) ()))))) ((and (cons? V13312) (and (= lambda (hd V13312)) (and (cons? (tl V13312)) (and (cons? (tl (tl V13312))) (= () (tl (tl (tl V13312)))))))) (cons lambda (cons (hd (tl V13312)) (cons (shen.assign-types (cons (hd (tl V13312)) V13310) V13311 (hd (tl (tl V13312)))) ())))) ((and (cons? V13312) (= cond (hd V13312))) (cons cond (map (lambda Y (cons (shen.assign-types V13310 V13311 (hd Y)) (cons (shen.assign-types V13310 V13311 (hd (tl Y))) ()))) (tl V13312)))) ((cons? V13312) (let NewTable (shen.typextable (shen.get-type (hd V13312)) (tl V13312)) (cons (hd V13312) (map (lambda Y (shen.assign-types V13310 (append V13311 NewTable) Y)) (tl V13312))))) (true (let AtomType (assoc V13312 V13311) (if (cons? AtomType) (cons type (cons V13312 (cons (tl AtomType) ()))) (if (element? V13312 V13310) V13312 (shen.atom-type V13312)))))))

(defun shen.atom-type (V13314) (if (string? V13314) (cons type (cons V13314 (cons string ()))) (if (number? V13314) (cons type (cons V13314 (cons number ()))) (if (boolean? V13314) (cons type (cons V13314 (cons boolean ()))) (if (symbol? V13314) (cons type (cons V13314 (cons symbol ()))) V13314)))))

(defun shen.store-arity (V13319 V13320) (cond ((value shen.*installing-kl*) shen.skip) (true (put V13319 arity V13320 (value *property-vector*)))))

(defun shen.reduce (V13322) (do (set shen.*teststack* ()) (let Result (shen.reduce_help V13322) (cons (cons : (cons shen.tests (reverse (value shen.*teststack*)))) (cons Result ())))))

(defun shen.reduce_help (V13324) (cond ((and (cons? V13324) (and (cons? (hd V13324)) (and (= /. (hd (hd V13324))) (and (cons? (tl (hd V13324))) (and (cons? (hd (tl (hd V13324)))) (and (= cons (hd (hd (tl (hd V13324))))) (and (cons? (tl (hd (tl (hd V13324))))) (and (cons? (tl (tl (hd (tl (hd V13324)))))) (and (= () (tl (tl (tl (hd (tl (hd V13324))))))) (and (cons? (tl (tl (hd V13324)))) (and (= () (tl (tl (tl (hd V13324))))) (and (cons? (tl V13324)) (= () (tl (tl V13324))))))))))))))) (do (shen.add_test (cons cons? (tl V13324))) (let Abstraction (cons /. (cons (hd (tl (hd (tl (hd V13324))))) (cons (cons /. (cons (hd (tl (tl (hd (tl (hd V13324)))))) (cons (shen.ebr (hd (tl V13324)) (hd (tl (hd V13324))) (hd (tl (tl (hd V13324))))) ()))) ()))) (let Application (cons (cons Abstraction (cons (cons hd (tl V13324)) ())) (cons (cons tl (tl V13324)) ())) (shen.reduce_help Application))))) ((and (cons? V13324) (and (cons? (hd V13324)) (and (= /. (hd (hd V13324))) (and (cons? (tl (hd V13324))) (and (cons? (hd (tl (hd V13324)))) (and (= @p (hd (hd (tl (hd V13324))))) (and (cons? (tl (hd (tl (hd V13324))))) (and (cons? (tl (tl (hd (tl (hd V13324)))))) (and (= () (tl (tl (tl (hd (tl (hd V13324))))))) (and (cons? (tl (tl (hd V13324)))) (and (= () (tl (tl (tl (hd V13324))))) (and (cons? (tl V13324)) (= () (tl (tl V13324))))))))))))))) (do (shen.add_test (cons tuple? (tl V13324))) (let Abstraction (cons /. (cons (hd (tl (hd (tl (hd V13324))))) (cons (cons /. (cons (hd (tl (tl (hd (tl (hd V13324)))))) (cons (shen.ebr (hd (tl V13324)) (hd (tl (hd V13324))) (hd (tl (tl (hd V13324))))) ()))) ()))) (let Application (cons (cons Abstraction (cons (cons fst (tl V13324)) ())) (cons (cons snd (tl V13324)) ())) (shen.reduce_help Application))))) ((and (cons? V13324) (and (cons? (hd V13324)) (and (= /. (hd (hd V13324))) (and (cons? (tl (hd V13324))) (and (cons? (hd (tl (hd V13324)))) (and (= @v (hd (hd (tl (hd V13324))))) (and (cons? (tl (hd (tl (hd V13324))))) (and (cons? (tl (tl (hd (tl (hd V13324)))))) (and (= () (tl (tl (tl (hd (tl (hd V13324))))))) (and (cons? (tl (tl (hd V13324)))) (and (= () (tl (tl (tl (hd V13324))))) (and (cons? (tl V13324)) (= () (tl (tl V13324))))))))))))))) (do (shen.add_test (cons shen.+vector? (tl V13324))) (let Abstraction (cons /. (cons (hd (tl (hd (tl (hd V13324))))) (cons (cons /. (cons (hd (tl (tl (hd (tl (hd V13324)))))) (cons (shen.ebr (hd (tl V13324)) (hd (tl (hd V13324))) (hd (tl (tl (hd V13324))))) ()))) ()))) (let Application (cons (cons Abstraction (cons (cons hdv (tl V13324)) ())) (cons (cons tlv (tl V13324)) ())) (shen.reduce_help Application))))) ((and (cons? V13324) (and (cons? (hd V13324)) (and (= /. (hd (hd V13324))) (and (cons? (tl (hd V13324))) (and (cons? (hd (tl (hd V13324)))) (and (= @s (hd (hd (tl (hd V13324))))) (and (cons? (tl (hd (tl (hd V13324))))) (and (cons? (tl (tl (hd (tl (hd V13324)))))) (and (= () (tl (tl (tl (hd (tl (hd V13324))))))) (and (cons? (tl (tl (hd V13324)))) (and (= () (tl (tl (tl (hd V13324))))) (and (cons? (tl V13324)) (= () (tl (tl V13324))))))))))))))) (do (shen.add_test (cons shen.+string? (tl V13324))) (let Abstraction (cons /. (cons (hd (tl (hd (tl (hd V13324))))) (cons (cons /. (cons (hd (tl (tl (hd (tl (hd V13324)))))) (cons (shen.ebr (hd (tl V13324)) (hd (tl (hd V13324))) (hd (tl (tl (hd V13324))))) ()))) ()))) (let Application (cons (cons Abstraction (cons (cons pos (cons (hd (tl V13324)) (cons 0 ()))) ())) (cons (cons tlstr (tl V13324)) ())) (shen.reduce_help Application))))) ((and (cons? V13324) (and (cons? (hd V13324)) (and (= /. (hd (hd V13324))) (and (cons? (tl (hd V13324))) (and (cons? (tl (tl (hd V13324)))) (and (= () (tl (tl (tl (hd V13324))))) (and (cons? (tl V13324)) (and (= () (tl (tl V13324))) (not (variable? (hd (tl (hd V13324))))))))))))) (do (shen.add_test (cons = (cons (hd (tl (hd V13324))) (tl V13324)))) (shen.reduce_help (hd (tl (tl (hd V13324))))))) ((and (cons? V13324) (and (cons? (hd V13324)) (and (= /. (hd (hd V13324))) (and (cons? (tl (hd V13324))) (and (cons? (tl (tl (hd V13324)))) (and (= () (tl (tl (tl (hd V13324))))) (and (cons? (tl V13324)) (= () (tl (tl V13324)))))))))) (shen.reduce_help (shen.ebr (hd (tl V13324)) (hd (tl (hd V13324))) (hd (tl (tl (hd V13324))))))) ((and (cons? V13324) (and (= where (hd V13324)) (and (cons? (tl V13324)) (and (cons? (tl (tl V13324))) (= () (tl (tl (tl V13324)))))))) (do (shen.add_test (hd (tl V13324))) (shen.reduce_help (hd (tl (tl V13324)))))) ((and (cons? V13324) (and (cons? (tl V13324)) (= () (tl (tl V13324))))) (let Z (shen.reduce_help (hd V13324)) (if (= (hd V13324) Z) V13324 (shen.reduce_help (cons Z (tl V13324)))))) (true V13324)))

(defun shen.+string? (V13326) (cond ((= "" V13326) false) (true (string? V13326))))

(defun shen.+vector (V13328) (cond ((= V13328 (vector 0)) false) (true (vector? V13328))))

(defun shen.ebr (V13342 V13343 V13344) (cond ((= V13344 V13343) V13342) ((and (cons? V13344) (and (= /. (hd V13344)) (and (cons? (tl V13344)) (and (cons? (tl (tl V13344))) (and (= () (tl (tl (tl V13344)))) (> (occurrences V13343 (hd (tl V13344))) 0)))))) V13344) ((and (cons? V13344) (and (= lambda (hd V13344)) (and (cons? (tl V13344)) (and (cons? (tl (tl V13344))) (and (= () (tl (tl (tl V13344)))) (> (occurrences V13343 (hd (tl V13344))) 0)))))) V13344) ((and (cons? V13344) (and (= let (hd V13344)) (and (cons? (tl V13344)) (and (cons? (tl (tl V13344))) (and (cons? (tl (tl (tl V13344)))) (and (= () (tl (tl (tl (tl V13344))))) (= (hd (tl V13344)) V13343))))))) (cons let (cons (hd (tl V13344)) (cons (shen.ebr V13342 (hd (tl V13344)) (hd (tl (tl V13344)))) (tl (tl (tl V13344))))))) ((cons? V13344) (cons (shen.ebr V13342 V13343 (hd V13344)) (shen.ebr V13342 V13343 (tl V13344)))) (true V13344)))

(defun shen.add_test (V13346) (set shen.*teststack* (cons V13346 (value shen.*teststack*))))

(defun shen.cond-expression (V13350 V13351 V13352) (let Err (shen.err-condition V13350) (let Cases (shen.case-form V13352 Err) (let EncodeChoices (shen.encode-choices Cases V13350) (shen.cond-form EncodeChoices)))))

(defun shen.cond-form (V13356) (cond ((and (cons? V13356) (and (cons? (hd V13356)) (and (= true (hd (hd V13356))) (and (cons? (tl (hd V13356))) (= () (tl (tl (hd V13356)))))))) (hd (tl (hd V13356)))) (true (cons cond V13356))))

(defun shen.encode-choices (V13361 V13362) (cond ((= () V13361) ()) ((and (cons? V13361) (and (cons? (hd V13361)) (and (= true (hd (hd V13361))) (and (cons? (tl (hd V13361))) (and (cons? (hd (tl (hd V13361)))) (and (= shen.choicepoint! (hd (hd (tl (hd V13361))))) (and (cons? (tl (hd (tl (hd V13361))))) (and (= () (tl (tl (hd (tl (hd V13361)))))) (and (= () (tl (tl (hd V13361)))) (= () (tl V13361))))))))))) (cons (cons true (cons (cons let (cons Result (cons (hd (tl (hd (tl (hd V13361))))) (cons (cons if (cons (cons = (cons Result (cons (cons fail ()) ()))) (cons (if (value shen.*installing-kl*) (cons shen.sys-error (cons V13362 ())) (cons shen.f_error (cons V13362 ()))) (cons Result ())))) ())))) ())) ())) ((and (cons? V13361) (and (cons? (hd V13361)) (and (= true (hd (hd V13361))) (and (cons? (tl (hd V13361))) (and (cons? (hd (tl (hd V13361)))) (and (= shen.choicepoint! (hd (hd (tl (hd V13361))))) (and (cons? (tl (hd (tl (hd V13361))))) (and (= () (tl (tl (hd (tl (hd V13361)))))) (= () (tl (tl (hd V13361)))))))))))) (cons (cons true (cons (cons let (cons Result (cons (hd (tl (hd (tl (hd V13361))))) (cons (cons if (cons (cons = (cons Result (cons (cons fail ()) ()))) (cons (shen.cond-form (shen.encode-choices (tl V13361) V13362)) (cons Result ())))) ())))) ())) ())) ((and (cons? V13361) (and (cons? (hd V13361)) (and (cons? (tl (hd V13361))) (and (cons? (hd (tl (hd V13361)))) (and (= shen.choicepoint! (hd (hd (tl (hd V13361))))) (and (cons? (tl (hd (tl (hd V13361))))) (and (= () (tl (tl (hd (tl (hd V13361)))))) (= () (tl (tl (hd V13361))))))))))) (cons (cons true (cons (cons let (cons Freeze (cons (cons freeze (cons (shen.cond-form (shen.encode-choices (tl V13361) V13362)) ())) (cons (cons if (cons (hd (hd V13361)) (cons (cons let (cons Result (cons (hd (tl (hd (tl (hd V13361))))) (cons (cons if (cons (cons = (cons Result (cons (cons fail ()) ()))) (cons (cons thaw (cons Freeze ())) (cons Result ())))) ())))) (cons (cons thaw (cons Freeze ())) ())))) ())))) ())) ())) ((and (cons? V13361) (and (cons? (hd V13361)) (and (cons? (tl (hd V13361))) (= () (tl (tl (hd V13361))))))) (cons (hd V13361) (shen.encode-choices (tl V13361) V13362))) (true (shen.f_error shen.encode-choices))))

(defun shen.case-form (V13369 V13370) (cond ((= () V13369) (cons V13370 ())) ((and (cons? V13369) (and (cons? (hd V13369)) (and (cons? (hd (hd V13369))) (and (= : (hd (hd (hd V13369)))) (and (cons? (tl (hd (hd V13369)))) (and (= shen.tests (hd (tl (hd (hd V13369))))) (and (= () (tl (tl (hd (hd V13369))))) (and (cons? (tl (hd V13369))) (and (cons? (hd (tl (hd V13369)))) (and (= shen.choicepoint! (hd (hd (tl (hd V13369))))) (and (cons? (tl (hd (tl (hd V13369))))) (and (= () (tl (tl (hd (tl (hd V13369)))))) (= () (tl (tl (hd V13369)))))))))))))))) (cons (cons true (tl (hd V13369))) (shen.case-form (tl V13369) V13370))) ((and (cons? V13369) (and (cons? (hd V13369)) (and (cons? (hd (hd V13369))) (and (= : (hd (hd (hd V13369)))) (and (cons? (tl (hd (hd V13369)))) (and (= shen.tests (hd (tl (hd (hd V13369))))) (and (= () (tl (tl (hd (hd V13369))))) (and (cons? (tl (hd V13369))) (= () (tl (tl (hd V13369)))))))))))) (cons (cons true (tl (hd V13369))) ())) ((and (cons? V13369) (and (cons? (hd V13369)) (and (cons? (hd (hd V13369))) (and (= : (hd (hd (hd V13369)))) (and (cons? (tl (hd (hd V13369)))) (and (= shen.tests (hd (tl (hd (hd V13369))))) (and (cons? (tl (hd V13369))) (= () (tl (tl (hd V13369))))))))))) (cons (cons (shen.embed-and (tl (tl (hd (hd V13369))))) (tl (hd V13369))) (shen.case-form (tl V13369) V13370))) (true (shen.f_error shen.case-form))))

(defun shen.embed-and (V13372) (cond ((and (cons? V13372) (= () (tl V13372))) (hd V13372)) ((cons? V13372) (cons and (cons (hd V13372) (cons (shen.embed-and (tl V13372)) ())))) (true (shen.f_error shen.embed-and))))

(defun shen.err-condition (V13374) (cons true (cons (cons shen.f_error (cons V13374 ())) ())))

(defun shen.sys-error (V13376) (simple-error (cn "system function " (shen.app V13376 ": unexpected argument
" shen.a))))



