"Copyright (c) 2015, Mark Tarver

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
1. Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.
3. The name of Mark Tarver may not be used to endorse or promote products
   derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY Mark Tarver ''AS IS'' AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL Mark Tarver BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."

(defun shen.<defprolog> (V13538) (let Parse_shen.<predicate*> (shen.<predicate*> V13538) (if (not (= (fail) Parse_shen.<predicate*>)) (let Parse_shen.<clauses*> (shen.<clauses*> Parse_shen.<predicate*>) (if (not (= (fail) Parse_shen.<clauses*>)) (shen.pair (hd Parse_shen.<clauses*>) (hd (shen.prolog->shen (map (lambda Parse_X (shen.insert-predicate (shen.hdtl Parse_shen.<predicate*>) Parse_X)) (shen.hdtl Parse_shen.<clauses*>))))) (fail))) (fail))))

(defun shen.prolog-error (V13547 V13548) (cond ((and (cons? V13548) (and (cons? (tl V13548)) (= () (tl (tl V13548))))) (simple-error (cn "prolog syntax error in " (shen.app V13547 (cn " here:

 " (shen.app (shen.next-50 50 (hd V13548)) "
" shen.a)) shen.a)))) (true (simple-error (cn "prolog syntax error in " (shen.app V13547 "
" shen.a))))))

(defun shen.next-50 (V13555 V13556) (cond ((= () V13556) "") ((= 0 V13555) "") ((cons? V13556) (cn (shen.decons-string (hd V13556)) (shen.next-50 (- V13555 1) (tl V13556)))) (true (shen.f_error shen.next-50))))

(defun shen.decons-string (V13558) (cond ((and (cons? V13558) (and (= cons (hd V13558)) (and (cons? (tl V13558)) (and (cons? (tl (tl V13558))) (= () (tl (tl (tl V13558)))))))) (shen.app (shen.eval-cons V13558) " " shen.s)) (true (shen.app V13558 " " shen.r))))

(defun shen.insert-predicate (V13561 V13562) (cond ((and (cons? V13562) (and (cons? (tl V13562)) (= () (tl (tl V13562))))) (cons (cons V13561 (hd V13562)) (cons :- (tl V13562)))) (true (shen.f_error shen.insert-predicate))))

(defun shen.<predicate*> (V13564) (if (cons? (hd V13564)) (let Parse_X (hd (hd V13564)) (shen.pair (hd (shen.pair (tl (hd V13564)) (shen.hdtl V13564))) Parse_X)) (fail)))

(defun shen.<clauses*> (V13566) (let YaccParse (let Parse_shen.<clause*> (shen.<clause*> V13566) (if (not (= (fail) Parse_shen.<clause*>)) (let Parse_shen.<clauses*> (shen.<clauses*> Parse_shen.<clause*>) (if (not (= (fail) Parse_shen.<clauses*>)) (shen.pair (hd Parse_shen.<clauses*>) (cons (shen.hdtl Parse_shen.<clause*>) (shen.hdtl Parse_shen.<clauses*>))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_<e> (<e> V13566) (if (not (= (fail) Parse_<e>)) (shen.pair (hd Parse_<e>) ()) (fail))) YaccParse)))

(defun shen.<clause*> (V13568) (let Parse_shen.<head*> (shen.<head*> V13568) (if (not (= (fail) Parse_shen.<head*>)) (if (and (cons? (hd Parse_shen.<head*>)) (= <-- (hd (hd Parse_shen.<head*>)))) (let Parse_shen.<body*> (shen.<body*> (shen.pair (tl (hd Parse_shen.<head*>)) (shen.hdtl Parse_shen.<head*>))) (if (not (= (fail) Parse_shen.<body*>)) (let Parse_shen.<end*> (shen.<end*> Parse_shen.<body*>) (if (not (= (fail) Parse_shen.<end*>)) (shen.pair (hd Parse_shen.<end*>) (cons (shen.hdtl Parse_shen.<head*>) (cons (shen.hdtl Parse_shen.<body*>) ()))) (fail))) (fail))) (fail)) (fail))))

(defun shen.<head*> (V13570) (let YaccParse (let Parse_shen.<term*> (shen.<term*> V13570) (if (not (= (fail) Parse_shen.<term*>)) (let Parse_shen.<head*> (shen.<head*> Parse_shen.<term*>) (if (not (= (fail) Parse_shen.<head*>)) (shen.pair (hd Parse_shen.<head*>) (cons (shen.hdtl Parse_shen.<term*>) (shen.hdtl Parse_shen.<head*>))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_<e> (<e> V13570) (if (not (= (fail) Parse_<e>)) (shen.pair (hd Parse_<e>) ()) (fail))) YaccParse)))

(defun shen.<term*> (V13572) (if (cons? (hd V13572)) (let Parse_X (hd (hd V13572)) (if (and (not (= <-- Parse_X)) (shen.legitimate-term? Parse_X)) (shen.pair (hd (shen.pair (tl (hd V13572)) (shen.hdtl V13572))) (shen.eval-cons Parse_X)) (fail))) (fail)))

(defun shen.legitimate-term? (V13578) (cond ((and (cons? V13578) (and (= cons (hd V13578)) (and (cons? (tl V13578)) (and (cons? (tl (tl V13578))) (= () (tl (tl (tl V13578)))))))) (and (shen.legitimate-term? (hd (tl V13578))) (shen.legitimate-term? (hd (tl (tl V13578)))))) ((and (cons? V13578) (and (= mode (hd V13578)) (and (cons? (tl V13578)) (and (cons? (tl (tl V13578))) (and (= + (hd (tl (tl V13578)))) (= () (tl (tl (tl V13578))))))))) (shen.legitimate-term? (hd (tl V13578)))) ((and (cons? V13578) (and (= mode (hd V13578)) (and (cons? (tl V13578)) (and (cons? (tl (tl V13578))) (and (= - (hd (tl (tl V13578)))) (= () (tl (tl (tl V13578))))))))) (shen.legitimate-term? (hd (tl V13578)))) ((cons? V13578) false) (true true)))

(defun shen.eval-cons (V13580) (cond ((and (cons? V13580) (and (= cons (hd V13580)) (and (cons? (tl V13580)) (and (cons? (tl (tl V13580))) (= () (tl (tl (tl V13580)))))))) (cons (shen.eval-cons (hd (tl V13580))) (shen.eval-cons (hd (tl (tl V13580)))))) ((and (cons? V13580) (and (= mode (hd V13580)) (and (cons? (tl V13580)) (and (cons? (tl (tl V13580))) (= () (tl (tl (tl V13580)))))))) (cons mode (cons (shen.eval-cons (hd (tl V13580))) (tl (tl V13580))))) (true V13580)))

(defun shen.<body*> (V13582) (let YaccParse (let Parse_shen.<literal*> (shen.<literal*> V13582) (if (not (= (fail) Parse_shen.<literal*>)) (let Parse_shen.<body*> (shen.<body*> Parse_shen.<literal*>) (if (not (= (fail) Parse_shen.<body*>)) (shen.pair (hd Parse_shen.<body*>) (cons (shen.hdtl Parse_shen.<literal*>) (shen.hdtl Parse_shen.<body*>))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_<e> (<e> V13582) (if (not (= (fail) Parse_<e>)) (shen.pair (hd Parse_<e>) ()) (fail))) YaccParse)))

(defun shen.<literal*> (V13584) (let YaccParse (if (and (cons? (hd V13584)) (= ! (hd (hd V13584)))) (shen.pair (hd (shen.pair (tl (hd V13584)) (shen.hdtl V13584))) (cons cut (cons (intern "Throwcontrol") ()))) (fail)) (if (= YaccParse (fail)) (if (cons? (hd V13584)) (let Parse_X (hd (hd V13584)) (if (cons? Parse_X) (shen.pair (hd (shen.pair (tl (hd V13584)) (shen.hdtl V13584))) Parse_X) (fail))) (fail)) YaccParse)))

(defun shen.<end*> (V13586) (if (cons? (hd V13586)) (let Parse_X (hd (hd V13586)) (if (= Parse_X ;) (shen.pair (hd (shen.pair (tl (hd V13586)) (shen.hdtl V13586))) Parse_X) (fail))) (fail)))

(defun cut (V13590 V13591 V13592) (let Result (thaw V13592) (if (= Result false) V13590 Result)))

(defun shen.insert_modes (V13594) (cond ((and (cons? V13594) (and (= mode (hd V13594)) (and (cons? (tl V13594)) (and (cons? (tl (tl V13594))) (= () (tl (tl (tl V13594)))))))) V13594) ((= () V13594) ()) ((cons? V13594) (cons (cons mode (cons (hd V13594) (cons + ()))) (cons mode (cons (shen.insert_modes (tl V13594)) (cons - ()))))) (true V13594)))

(defun shen.s-prolog (V13596) (map (lambda X (eval X)) (shen.prolog->shen V13596)))

(defun shen.prolog->shen (V13598) (map (lambda X (shen.compile_prolog_procedure X)) (shen.group_clauses (map (lambda X (shen.s-prolog_clause X)) (mapcan (lambda X (shen.head_abstraction X)) V13598)))))

(defun shen.s-prolog_clause (V13600) (cond ((and (cons? V13600) (and (cons? (tl V13600)) (and (= :- (hd (tl V13600))) (and (cons? (tl (tl V13600))) (= () (tl (tl (tl V13600)))))))) (cons (hd V13600) (cons :- (cons (map (lambda X (shen.s-prolog_literal X)) (hd (tl (tl V13600)))) ())))) (true (shen.f_error shen.s-prolog_clause))))

(defun shen.head_abstraction (V13602) (cond ((and (cons? V13602) (and (cons? (tl V13602)) (and (= :- (hd (tl V13602))) (and (cons? (tl (tl V13602))) (and (= () (tl (tl (tl V13602)))) (< (shen.complexity_head (hd V13602)) (value shen.*maxcomplexity*))))))) (cons V13602 ())) ((and (cons? V13602) (and (cons? (hd V13602)) (and (cons? (tl V13602)) (and (= :- (hd (tl V13602))) (and (cons? (tl (tl V13602))) (= () (tl (tl (tl V13602))))))))) (let Terms (map (lambda Y (gensym V)) (tl (hd V13602))) (let XTerms (shen.rcons_form (shen.remove_modes (tl (hd V13602)))) (let Literal (cons unify (cons (shen.cons_form Terms) (cons XTerms ()))) (let Clause (cons (cons (hd (hd V13602)) Terms) (cons :- (cons (cons Literal (hd (tl (tl V13602)))) ()))) (cons Clause ())))))) (true (shen.f_error shen.head_abstraction))))

(defun shen.complexity_head (V13608) (cond ((cons? V13608) (shen.product (map (lambda X (shen.complexity X)) (tl V13608)))) (true (shen.f_error shen.complexity_head))))

(defun shen.complexity (V13617) (cond ((and (cons? V13617) (and (= mode (hd V13617)) (and (cons? (tl V13617)) (and (cons? (hd (tl V13617))) (and (= mode (hd (hd (tl V13617)))) (and (cons? (tl (hd (tl V13617)))) (and (cons? (tl (tl (hd (tl V13617))))) (and (= () (tl (tl (tl (hd (tl V13617)))))) (and (cons? (tl (tl V13617))) (= () (tl (tl (tl V13617))))))))))))) (shen.complexity (hd (tl V13617)))) ((and (cons? V13617) (and (= mode (hd V13617)) (and (cons? (tl V13617)) (and (cons? (hd (tl V13617))) (and (cons? (tl (tl V13617))) (and (= + (hd (tl (tl V13617)))) (= () (tl (tl (tl V13617)))))))))) (* 2 (* (shen.complexity (cons mode (cons (hd (hd (tl V13617))) (tl (tl V13617))))) (shen.complexity (cons mode (cons (tl (hd (tl V13617))) (tl (tl V13617)))))))) ((and (cons? V13617) (and (= mode (hd V13617)) (and (cons? (tl V13617)) (and (cons? (hd (tl V13617))) (and (cons? (tl (tl V13617))) (and (= - (hd (tl (tl V13617)))) (= () (tl (tl (tl V13617)))))))))) (* (shen.complexity (cons mode (cons (hd (hd (tl V13617))) (tl (tl V13617))))) (shen.complexity (cons mode (cons (tl (hd (tl V13617))) (tl (tl V13617))))))) ((and (cons? V13617) (and (= mode (hd V13617)) (and (cons? (tl V13617)) (and (cons? (tl (tl V13617))) (and (= () (tl (tl (tl V13617)))) (variable? (hd (tl V13617)))))))) 1) ((and (cons? V13617) (and (= mode (hd V13617)) (and (cons? (tl V13617)) (and (cons? (tl (tl V13617))) (and (= + (hd (tl (tl V13617)))) (= () (tl (tl (tl V13617))))))))) 2) ((and (cons? V13617) (and (= mode (hd V13617)) (and (cons? (tl V13617)) (and (cons? (tl (tl V13617))) (and (= - (hd (tl (tl V13617)))) (= () (tl (tl (tl V13617))))))))) 1) (true (shen.complexity (cons mode (cons V13617 (cons + ())))))))

(defun shen.product (V13619) (cond ((= () V13619) 1) ((cons? V13619) (* (hd V13619) (shen.product (tl V13619)))) (true (shen.f_error shen.product))))

(defun shen.s-prolog_literal (V13621) (cond ((and (cons? V13621) (and (= is (hd V13621)) (and (cons? (tl V13621)) (and (cons? (tl (tl V13621))) (= () (tl (tl (tl V13621)))))))) (cons bind (cons (hd (tl V13621)) (cons (shen.insert_deref (hd (tl (tl V13621)))) ())))) ((and (cons? V13621) (and (= when (hd V13621)) (and (cons? (tl V13621)) (= () (tl (tl V13621)))))) (cons fwhen (cons (shen.insert_deref (hd (tl V13621))) ()))) ((and (cons? V13621) (and (= bind (hd V13621)) (and (cons? (tl V13621)) (and (cons? (tl (tl V13621))) (= () (tl (tl (tl V13621)))))))) (cons bind (cons (hd (tl V13621)) (cons (shen.insert_lazyderef (hd (tl (tl V13621)))) ())))) ((and (cons? V13621) (and (= fwhen (hd V13621)) (and (cons? (tl V13621)) (= () (tl (tl V13621)))))) (cons fwhen (cons (shen.insert_lazyderef (hd (tl V13621))) ()))) ((cons? V13621) V13621) (true (shen.f_error shen.s-prolog_literal))))

(defun shen.insert_deref (V13623) (cond ((variable? V13623) (cons shen.deref (cons V13623 (cons ProcessN ())))) ((cons? V13623) (cons (shen.insert_deref (hd V13623)) (shen.insert_deref (tl V13623)))) (true V13623)))

(defun shen.insert_lazyderef (V13625) (cond ((variable? V13625) (cons shen.lazyderef (cons V13625 (cons ProcessN ())))) ((cons? V13625) (cons (shen.insert_lazyderef (hd V13625)) (shen.insert_lazyderef (tl V13625)))) (true V13625)))

(defun shen.group_clauses (V13627) (cond ((= () V13627) ()) ((cons? V13627) (let Group (shen.collect (lambda X (shen.same_predicate? (hd V13627) X)) V13627) (let Rest (difference V13627 Group) (cons Group (shen.group_clauses Rest))))) (true (shen.f_error shen.group_clauses))))

(defun shen.collect (V13632 V13633) (cond ((= () V13633) ()) ((cons? V13633) (if (V13632 (hd V13633)) (cons (hd V13633) (shen.collect V13632 (tl V13633))) (shen.collect V13632 (tl V13633)))) (true (shen.f_error shen.collect))))

(defun shen.same_predicate? (V13652 V13653) (cond ((and (cons? V13652) (and (cons? (hd V13652)) (and (cons? V13653) (cons? (hd V13653))))) (= (hd (hd V13652)) (hd (hd V13653)))) (true (shen.f_error shen.same_predicate?))))

(defun shen.compile_prolog_procedure (V13655) (let F (shen.procedure_name V13655) (let Shen (shen.clauses-to-shen F V13655) Shen)))

(defun shen.procedure_name (V13669) (cond ((and (cons? V13669) (and (cons? (hd V13669)) (cons? (hd (hd V13669))))) (hd (hd (hd V13669)))) (true (shen.f_error shen.procedure_name))))

(defun shen.clauses-to-shen (V13672 V13673) (let Linear (map (lambda X (shen.linearise-clause X)) V13673) (let Arity (shen.prolog-aritycheck V13672 (map (lambda X (head X)) V13673)) (let Parameters (shen.parameters Arity) (let AUM_instructions (map (lambda X (shen.aum X Parameters)) Linear) (let Code (shen.catch-cut (shen.nest-disjunct (map (lambda X (shen.aum_to_shen X)) AUM_instructions))) (let ShenDef (cons define (cons V13672 (append Parameters (append (cons ProcessN (cons Continuation ())) (cons -> (cons Code ())))))) ShenDef)))))))

(defun shen.catch-cut (V13675) (cond ((not (shen.occurs? cut V13675)) V13675) (true (cons let (cons Throwcontrol (cons (cons shen.catchpoint ()) (cons (cons shen.cutpoint (cons Throwcontrol (cons V13675 ()))) ())))))))

(defun shen.catchpoint () (set shen.*catch* (+ 1 (value shen.*catch*))))

(defun shen.cutpoint (V13683 V13684) (cond ((= V13684 V13683) false) (true V13684)))

(defun shen.nest-disjunct (V13686) (cond ((and (cons? V13686) (= () (tl V13686))) (hd V13686)) ((cons? V13686) (shen.lisp-or (hd V13686) (shen.nest-disjunct (tl V13686)))) (true (shen.f_error shen.nest-disjunct))))

(defun shen.lisp-or (V13689 V13690) (cons let (cons Case (cons V13689 (cons (cons if (cons (cons = (cons Case (cons false ()))) (cons V13690 (cons Case ())))) ())))))

(defun shen.prolog-aritycheck (V13695 V13696) (cond ((and (cons? V13696) (= () (tl V13696))) (- (length (hd V13696)) 1)) ((and (cons? V13696) (cons? (tl V13696))) (if (= (length (hd V13696)) (length (hd (tl V13696)))) (shen.prolog-aritycheck V13695 (tl V13696)) (simple-error (cn "arity error in prolog procedure " (shen.app (cons V13695 ()) "
" shen.a))))) (true (shen.f_error shen.prolog-aritycheck))))

(defun shen.linearise-clause (V13698) (cond ((and (cons? V13698) (and (cons? (tl V13698)) (and (= :- (hd (tl V13698))) (and (cons? (tl (tl V13698))) (= () (tl (tl (tl V13698)))))))) (let Linear (shen.linearise (cons (hd V13698) (tl (tl V13698)))) (shen.clause_form Linear))) (true (shen.f_error shen.linearise-clause))))

(defun shen.clause_form (V13700) (cond ((and (cons? V13700) (and (cons? (tl V13700)) (= () (tl (tl V13700))))) (cons (shen.explicit_modes (hd V13700)) (cons :- (cons (shen.cf_help (hd (tl V13700))) ())))) (true (shen.f_error shen.clause_form))))

(defun shen.explicit_modes (V13702) (cond ((cons? V13702) (cons (hd V13702) (map (lambda X (shen.em_help X)) (tl V13702)))) (true (shen.f_error shen.explicit_modes))))

(defun shen.em_help (V13704) (cond ((and (cons? V13704) (and (= mode (hd V13704)) (and (cons? (tl V13704)) (and (cons? (tl (tl V13704))) (= () (tl (tl (tl V13704)))))))) V13704) (true (cons mode (cons V13704 (cons + ()))))))

(defun shen.cf_help (V13706) (cond ((and (cons? V13706) (and (= where (hd V13706)) (and (cons? (tl V13706)) (and (cons? (hd (tl V13706))) (and (= = (hd (hd (tl V13706)))) (and (cons? (tl (hd (tl V13706)))) (and (cons? (tl (tl (hd (tl V13706))))) (and (= () (tl (tl (tl (hd (tl V13706)))))) (and (cons? (tl (tl V13706))) (= () (tl (tl (tl V13706))))))))))))) (cons (cons (if (value shen.*occurs*) unify! unify) (tl (hd (tl V13706)))) (shen.cf_help (hd (tl (tl V13706)))))) (true V13706)))

(defun occurs-check (V13712) (cond ((= + V13712) (set shen.*occurs* true)) ((= - V13712) (set shen.*occurs* false)) (true (simple-error "occurs-check expects + or -
"))))

(defun shen.aum (V13715 V13716) (cond ((and (cons? V13715) (and (cons? (hd V13715)) (and (cons? (tl V13715)) (and (= :- (hd (tl V13715))) (and (cons? (tl (tl V13715))) (= () (tl (tl (tl V13715))))))))) (let MuApplication (shen.make_mu_application (cons shen.mu (cons (tl (hd V13715)) (cons (shen.continuation_call (tl (hd V13715)) (hd (tl (tl V13715)))) ()))) V13716) (shen.mu_reduction MuApplication +))) (true (shen.f_error shen.aum))))

(defun shen.continuation_call (V13719 V13720) (let VTerms (cons ProcessN (shen.extract_vars V13719)) (let VBody (shen.extract_vars V13720) (let Free (remove Throwcontrol (difference VBody VTerms)) (shen.cc_help Free V13720)))))

(defun remove (V13723 V13724) (shen.remove-h V13723 V13724 ()))

(defun shen.remove-h (V13731 V13732 V13733) (cond ((= () V13732) (reverse V13733)) ((and (cons? V13732) (= (hd V13732) V13731)) (shen.remove-h (hd V13732) (tl V13732) V13733)) ((cons? V13732) (shen.remove-h V13731 (tl V13732) (cons (hd V13732) V13733))) (true (shen.f_error shen.remove-h))))

(defun shen.cc_help (V13736 V13737) (cond ((and (= () V13736) (= () V13737)) (cons shen.pop (cons shen.the (cons shen.stack ())))) ((= () V13737) (cons shen.rename (cons shen.the (cons shen.variables (cons in (cons V13736 (cons and (cons shen.then (cons (cons shen.pop (cons shen.the (cons shen.stack ()))) ()))))))))) ((= () V13736) (cons call (cons shen.the (cons shen.continuation (cons V13737 ()))))) (true (cons shen.rename (cons shen.the (cons shen.variables (cons in (cons V13736 (cons and (cons shen.then (cons (cons call (cons shen.the (cons shen.continuation (cons V13737 ())))) ())))))))))))

(defun shen.make_mu_application (V13740 V13741) (cond ((and (cons? V13740) (and (= shen.mu (hd V13740)) (and (cons? (tl V13740)) (and (= () (hd (tl V13740))) (and (cons? (tl (tl V13740))) (and (= () (tl (tl (tl V13740)))) (= () V13741))))))) (hd (tl (tl V13740)))) ((and (cons? V13740) (and (= shen.mu (hd V13740)) (and (cons? (tl V13740)) (and (cons? (hd (tl V13740))) (and (cons? (tl (tl V13740))) (and (= () (tl (tl (tl V13740)))) (cons? V13741))))))) (cons (cons shen.mu (cons (hd (hd (tl V13740))) (cons (shen.make_mu_application (cons shen.mu (cons (tl (hd (tl V13740))) (tl (tl V13740)))) (tl V13741)) ()))) (cons (hd V13741) ()))) (true (shen.f_error shen.make_mu_application))))

(defun shen.mu_reduction (V13750 V13751) (cond ((and (cons? V13750) (and (cons? (hd V13750)) (and (= shen.mu (hd (hd V13750))) (and (cons? (tl (hd V13750))) (and (cons? (hd (tl (hd V13750)))) (and (= mode (hd (hd (tl (hd V13750))))) (and (cons? (tl (hd (tl (hd V13750))))) (and (cons? (tl (tl (hd (tl (hd V13750)))))) (and (= () (tl (tl (tl (hd (tl (hd V13750))))))) (and (cons? (tl (tl (hd V13750)))) (and (= () (tl (tl (tl (hd V13750))))) (and (cons? (tl V13750)) (= () (tl (tl V13750))))))))))))))) (shen.mu_reduction (cons (cons shen.mu (cons (hd (tl (hd (tl (hd V13750))))) (tl (tl (hd V13750))))) (tl V13750)) (hd (tl (tl (hd (tl (hd V13750)))))))) ((and (cons? V13750) (and (cons? (hd V13750)) (and (= shen.mu (hd (hd V13750))) (and (cons? (tl (hd V13750))) (and (cons? (tl (tl (hd V13750)))) (and (= () (tl (tl (tl (hd V13750))))) (and (cons? (tl V13750)) (and (= () (tl (tl V13750))) (= _ (hd (tl (hd V13750)))))))))))) (shen.mu_reduction (hd (tl (tl (hd V13750)))) V13751)) ((and (cons? V13750) (and (cons? (hd V13750)) (and (= shen.mu (hd (hd V13750))) (and (cons? (tl (hd V13750))) (and (cons? (tl (tl (hd V13750)))) (and (= () (tl (tl (tl (hd V13750))))) (and (cons? (tl V13750)) (and (= () (tl (tl V13750))) (shen.ephemeral_variable? (hd (tl (hd V13750))) (hd (tl V13750))))))))))) (subst (hd (tl V13750)) (hd (tl (hd V13750))) (shen.mu_reduction (hd (tl (tl (hd V13750)))) V13751))) ((and (cons? V13750) (and (cons? (hd V13750)) (and (= shen.mu (hd (hd V13750))) (and (cons? (tl (hd V13750))) (and (cons? (tl (tl (hd V13750)))) (and (= () (tl (tl (tl (hd V13750))))) (and (cons? (tl V13750)) (and (= () (tl (tl V13750))) (variable? (hd (tl (hd V13750)))))))))))) (cons let (cons (hd (tl (hd V13750))) (cons shen.be (cons (hd (tl V13750)) (cons in (cons (shen.mu_reduction (hd (tl (tl (hd V13750)))) V13751) ()))))))) ((and (cons? V13750) (and (cons? (hd V13750)) (and (= shen.mu (hd (hd V13750))) (and (cons? (tl (hd V13750))) (and (cons? (tl (tl (hd V13750)))) (and (= () (tl (tl (tl (hd V13750))))) (and (cons? (tl V13750)) (and (= () (tl (tl V13750))) (and (= - V13751) (shen.prolog_constant? (hd (tl (hd V13750))))))))))))) (let Z (gensym V) (cons let (cons Z (cons shen.be (cons (cons shen.the (cons shen.result (cons shen.of (cons shen.dereferencing (tl V13750))))) (cons in (cons (cons if (cons (cons Z (cons is (cons identical (cons shen.to (cons (hd (tl (hd V13750))) ()))))) (cons shen.then (cons (shen.mu_reduction (hd (tl (tl (hd V13750)))) -) (cons shen.else (cons shen.failed! ())))))) ())))))))) ((and (cons? V13750) (and (cons? (hd V13750)) (and (= shen.mu (hd (hd V13750))) (and (cons? (tl (hd V13750))) (and (cons? (tl (tl (hd V13750)))) (and (= () (tl (tl (tl (hd V13750))))) (and (cons? (tl V13750)) (and (= () (tl (tl V13750))) (and (= + V13751) (shen.prolog_constant? (hd (tl (hd V13750))))))))))))) (let Z (gensym V) (cons let (cons Z (cons shen.be (cons (cons shen.the (cons shen.result (cons shen.of (cons shen.dereferencing (tl V13750))))) (cons in (cons (cons if (cons (cons Z (cons is (cons identical (cons shen.to (cons (hd (tl (hd V13750))) ()))))) (cons shen.then (cons (shen.mu_reduction (hd (tl (tl (hd V13750)))) +) (cons shen.else (cons (cons if (cons (cons Z (cons is (cons shen.a (cons shen.variable ())))) (cons shen.then (cons (cons bind (cons Z (cons shen.to (cons (hd (tl (hd V13750))) (cons in (cons (shen.mu_reduction (hd (tl (tl (hd V13750)))) +) ())))))) (cons shen.else (cons shen.failed! ())))))) ())))))) ())))))))) ((and (cons? V13750) (and (cons? (hd V13750)) (and (= shen.mu (hd (hd V13750))) (and (cons? (tl (hd V13750))) (and (cons? (hd (tl (hd V13750)))) (and (cons? (tl (tl (hd V13750)))) (and (= () (tl (tl (tl (hd V13750))))) (and (cons? (tl V13750)) (and (= () (tl (tl V13750))) (= - V13751)))))))))) (let Z (gensym V) (cons let (cons Z (cons shen.be (cons (cons shen.the (cons shen.result (cons shen.of (cons shen.dereferencing (tl V13750))))) (cons in (cons (cons if (cons (cons Z (cons is (cons shen.a (cons shen.non-empty (cons list ()))))) (cons shen.then (cons (shen.mu_reduction (cons (cons shen.mu (cons (hd (hd (tl (hd V13750)))) (cons (cons (cons shen.mu (cons (tl (hd (tl (hd V13750)))) (tl (tl (hd V13750))))) (cons (cons shen.the (cons tail (cons shen.of (cons Z ())))) ())) ()))) (cons (cons shen.the (cons head (cons shen.of (cons Z ())))) ())) -) (cons shen.else (cons shen.failed! ())))))) ())))))))) ((and (cons? V13750) (and (cons? (hd V13750)) (and (= shen.mu (hd (hd V13750))) (and (cons? (tl (hd V13750))) (and (cons? (hd (tl (hd V13750)))) (and (cons? (tl (tl (hd V13750)))) (and (= () (tl (tl (tl (hd V13750))))) (and (cons? (tl V13750)) (and (= () (tl (tl V13750))) (= + V13751)))))))))) (let Z (gensym V) (cons let (cons Z (cons shen.be (cons (cons shen.the (cons shen.result (cons shen.of (cons shen.dereferencing (tl V13750))))) (cons in (cons (cons if (cons (cons Z (cons is (cons shen.a (cons shen.non-empty (cons list ()))))) (cons shen.then (cons (shen.mu_reduction (cons (cons shen.mu (cons (hd (hd (tl (hd V13750)))) (cons (cons (cons shen.mu (cons (tl (hd (tl (hd V13750)))) (tl (tl (hd V13750))))) (cons (cons shen.the (cons tail (cons shen.of (cons Z ())))) ())) ()))) (cons (cons shen.the (cons head (cons shen.of (cons Z ())))) ())) +) (cons shen.else (cons (cons if (cons (cons Z (cons is (cons shen.a (cons shen.variable ())))) (cons shen.then (cons (cons shen.rename (cons shen.the (cons shen.variables (cons in (cons (shen.extract_vars (hd (tl (hd V13750)))) (cons and (cons shen.then (cons (cons bind (cons Z (cons shen.to (cons (shen.rcons_form (shen.remove_modes (hd (tl (hd V13750))))) (cons in (cons (shen.mu_reduction (hd (tl (tl (hd V13750)))) +) ())))))) ())))))))) (cons shen.else (cons shen.failed! ())))))) ())))))) ())))))))) (true V13750)))

(defun shen.rcons_form (V13753) (cond ((cons? V13753) (cons cons (cons (shen.rcons_form (hd V13753)) (cons (shen.rcons_form (tl V13753)) ())))) (true V13753)))

(defun shen.remove_modes (V13755) (cond ((and (cons? V13755) (and (= mode (hd V13755)) (and (cons? (tl V13755)) (and (cons? (tl (tl V13755))) (and (= + (hd (tl (tl V13755)))) (= () (tl (tl (tl V13755))))))))) (shen.remove_modes (hd (tl V13755)))) ((and (cons? V13755) (and (= mode (hd V13755)) (and (cons? (tl V13755)) (and (cons? (tl (tl V13755))) (and (= - (hd (tl (tl V13755)))) (= () (tl (tl (tl V13755))))))))) (shen.remove_modes (hd (tl V13755)))) ((cons? V13755) (cons (shen.remove_modes (hd V13755)) (shen.remove_modes (tl V13755)))) (true V13755)))

(defun shen.ephemeral_variable? (V13758 V13759) (and (variable? V13758) (variable? V13759)))

(defun shen.prolog_constant? (V13769) (cond ((cons? V13769) false) (true true)))

(defun shen.aum_to_shen (V13771) (cond ((and (cons? V13771) (and (= let (hd V13771)) (and (cons? (tl V13771)) (and (cons? (tl (tl V13771))) (and (= shen.be (hd (tl (tl V13771)))) (and (cons? (tl (tl (tl V13771)))) (and (cons? (tl (tl (tl (tl V13771))))) (and (= in (hd (tl (tl (tl (tl V13771)))))) (and (cons? (tl (tl (tl (tl (tl V13771)))))) (= () (tl (tl (tl (tl (tl (tl V13771)))))))))))))))) (cons let (cons (hd (tl V13771)) (cons (shen.aum_to_shen (hd (tl (tl (tl V13771))))) (cons (shen.aum_to_shen (hd (tl (tl (tl (tl (tl V13771))))))) ()))))) ((and (cons? V13771) (and (= shen.the (hd V13771)) (and (cons? (tl V13771)) (and (= shen.result (hd (tl V13771))) (and (cons? (tl (tl V13771))) (and (= shen.of (hd (tl (tl V13771)))) (and (cons? (tl (tl (tl V13771)))) (and (= shen.dereferencing (hd (tl (tl (tl V13771))))) (and (cons? (tl (tl (tl (tl V13771))))) (= () (tl (tl (tl (tl (tl V13771))))))))))))))) (cons shen.lazyderef (cons (shen.aum_to_shen (hd (tl (tl (tl (tl V13771)))))) (cons ProcessN ())))) ((and (cons? V13771) (and (= if (hd V13771)) (and (cons? (tl V13771)) (and (cons? (tl (tl V13771))) (and (= shen.then (hd (tl (tl V13771)))) (and (cons? (tl (tl (tl V13771)))) (and (cons? (tl (tl (tl (tl V13771))))) (and (= shen.else (hd (tl (tl (tl (tl V13771)))))) (and (cons? (tl (tl (tl (tl (tl V13771)))))) (= () (tl (tl (tl (tl (tl (tl V13771)))))))))))))))) (cons if (cons (shen.aum_to_shen (hd (tl V13771))) (cons (shen.aum_to_shen (hd (tl (tl (tl V13771))))) (cons (shen.aum_to_shen (hd (tl (tl (tl (tl (tl V13771))))))) ()))))) ((and (cons? V13771) (and (cons? (tl V13771)) (and (= is (hd (tl V13771))) (and (cons? (tl (tl V13771))) (and (= shen.a (hd (tl (tl V13771)))) (and (cons? (tl (tl (tl V13771)))) (and (= shen.variable (hd (tl (tl (tl V13771))))) (= () (tl (tl (tl (tl V13771)))))))))))) (cons shen.pvar? (cons (hd V13771) ()))) ((and (cons? V13771) (and (cons? (tl V13771)) (and (= is (hd (tl V13771))) (and (cons? (tl (tl V13771))) (and (= shen.a (hd (tl (tl V13771)))) (and (cons? (tl (tl (tl V13771)))) (and (= shen.non-empty (hd (tl (tl (tl V13771))))) (and (cons? (tl (tl (tl (tl V13771))))) (and (= list (hd (tl (tl (tl (tl V13771)))))) (= () (tl (tl (tl (tl (tl V13771))))))))))))))) (cons cons? (cons (hd V13771) ()))) ((and (cons? V13771) (and (= shen.rename (hd V13771)) (and (cons? (tl V13771)) (and (= shen.the (hd (tl V13771))) (and (cons? (tl (tl V13771))) (and (= shen.variables (hd (tl (tl V13771)))) (and (cons? (tl (tl (tl V13771)))) (and (= in (hd (tl (tl (tl V13771))))) (and (cons? (tl (tl (tl (tl V13771))))) (and (= () (hd (tl (tl (tl (tl V13771)))))) (and (cons? (tl (tl (tl (tl (tl V13771)))))) (and (= and (hd (tl (tl (tl (tl (tl V13771))))))) (and (cons? (tl (tl (tl (tl (tl (tl V13771))))))) (and (= shen.then (hd (tl (tl (tl (tl (tl (tl V13771)))))))) (and (cons? (tl (tl (tl (tl (tl (tl (tl V13771)))))))) (= () (tl (tl (tl (tl (tl (tl (tl (tl V13771)))))))))))))))))))))))) (shen.aum_to_shen (hd (tl (tl (tl (tl (tl (tl (tl V13771)))))))))) ((and (cons? V13771) (and (= shen.rename (hd V13771)) (and (cons? (tl V13771)) (and (= shen.the (hd (tl V13771))) (and (cons? (tl (tl V13771))) (and (= shen.variables (hd (tl (tl V13771)))) (and (cons? (tl (tl (tl V13771)))) (and (= in (hd (tl (tl (tl V13771))))) (and (cons? (tl (tl (tl (tl V13771))))) (and (cons? (hd (tl (tl (tl (tl V13771)))))) (and (cons? (tl (tl (tl (tl (tl V13771)))))) (and (= and (hd (tl (tl (tl (tl (tl V13771))))))) (and (cons? (tl (tl (tl (tl (tl (tl V13771))))))) (and (= shen.then (hd (tl (tl (tl (tl (tl (tl V13771)))))))) (and (cons? (tl (tl (tl (tl (tl (tl (tl V13771)))))))) (= () (tl (tl (tl (tl (tl (tl (tl (tl V13771)))))))))))))))))))))))) (cons let (cons (hd (hd (tl (tl (tl (tl V13771)))))) (cons (cons shen.newpv (cons ProcessN ())) (cons (shen.aum_to_shen (cons shen.rename (cons shen.the (cons shen.variables (cons in (cons (tl (hd (tl (tl (tl (tl V13771)))))) (tl (tl (tl (tl (tl V13771))))))))))) ()))))) ((and (cons? V13771) (and (= bind (hd V13771)) (and (cons? (tl V13771)) (and (cons? (tl (tl V13771))) (and (= shen.to (hd (tl (tl V13771)))) (and (cons? (tl (tl (tl V13771)))) (and (cons? (tl (tl (tl (tl V13771))))) (and (= in (hd (tl (tl (tl (tl V13771)))))) (and (cons? (tl (tl (tl (tl (tl V13771)))))) (= () (tl (tl (tl (tl (tl (tl V13771)))))))))))))))) (cons do (cons (cons shen.bindv (cons (hd (tl V13771)) (cons (shen.chwild (hd (tl (tl (tl V13771))))) (cons ProcessN ())))) (cons (cons let (cons Result (cons (shen.aum_to_shen (hd (tl (tl (tl (tl (tl V13771))))))) (cons (cons do (cons (cons shen.unbindv (cons (hd (tl V13771)) (cons ProcessN ()))) (cons Result ()))) ())))) ())))) ((and (cons? V13771) (and (cons? (tl V13771)) (and (= is (hd (tl V13771))) (and (cons? (tl (tl V13771))) (and (= identical (hd (tl (tl V13771)))) (and (cons? (tl (tl (tl V13771)))) (and (= shen.to (hd (tl (tl (tl V13771))))) (and (cons? (tl (tl (tl (tl V13771))))) (= () (tl (tl (tl (tl (tl V13771)))))))))))))) (cons = (cons (hd (tl (tl (tl (tl V13771))))) (cons (hd V13771) ())))) ((= shen.failed! V13771) false) ((and (cons? V13771) (and (= shen.the (hd V13771)) (and (cons? (tl V13771)) (and (= head (hd (tl V13771))) (and (cons? (tl (tl V13771))) (and (= shen.of (hd (tl (tl V13771)))) (and (cons? (tl (tl (tl V13771)))) (= () (tl (tl (tl (tl V13771)))))))))))) (cons hd (tl (tl (tl V13771))))) ((and (cons? V13771) (and (= shen.the (hd V13771)) (and (cons? (tl V13771)) (and (= tail (hd (tl V13771))) (and (cons? (tl (tl V13771))) (and (= shen.of (hd (tl (tl V13771)))) (and (cons? (tl (tl (tl V13771)))) (= () (tl (tl (tl (tl V13771)))))))))))) (cons tl (tl (tl (tl V13771))))) ((and (cons? V13771) (and (= shen.pop (hd V13771)) (and (cons? (tl V13771)) (and (= shen.the (hd (tl V13771))) (and (cons? (tl (tl V13771))) (and (= shen.stack (hd (tl (tl V13771)))) (= () (tl (tl (tl V13771)))))))))) (cons do (cons (cons shen.incinfs ()) (cons (cons thaw (cons Continuation ())) ())))) ((and (cons? V13771) (and (= call (hd V13771)) (and (cons? (tl V13771)) (and (= shen.the (hd (tl V13771))) (and (cons? (tl (tl V13771))) (and (= shen.continuation (hd (tl (tl V13771)))) (and (cons? (tl (tl (tl V13771)))) (= () (tl (tl (tl (tl V13771)))))))))))) (cons do (cons (cons shen.incinfs ()) (cons (shen.call_the_continuation (shen.chwild (hd (tl (tl (tl V13771))))) ProcessN Continuation) ())))) (true V13771)))

(defun shen.chwild (V13773) (cond ((= V13773 _) (cons shen.newpv (cons ProcessN ()))) ((cons? V13773) (map (lambda Z (shen.chwild Z)) V13773)) (true V13773)))

(defun shen.newpv (V13775) (let Count+1 (+ (<-address (value shen.*varcounter*) V13775) 1) (let IncVar (address-> (value shen.*varcounter*) V13775 Count+1) (let Vector (<-address (value shen.*prologvectors*) V13775) (let ResizeVectorIfNeeded (if (= Count+1 (limit Vector)) (shen.resizeprocessvector V13775 Count+1) shen.skip) (shen.mk-pvar Count+1))))))

(defun shen.resizeprocessvector (V13778 V13779) (let Vector (<-address (value shen.*prologvectors*) V13778) (let BigVector (shen.resize-vector Vector (+ V13779 V13779) shen.-null-) (address-> (value shen.*prologvectors*) V13778 BigVector))))

(defun shen.resize-vector (V13783 V13784 V13785) (let BigVector (address-> (absvector (+ 1 V13784)) 0 V13784) (shen.copy-vector V13783 BigVector (limit V13783) V13784 V13785)))

(defun shen.copy-vector (V13791 V13792 V13793 V13794 V13795) (shen.copy-vector-stage-2 (+ 1 V13793) (+ V13794 1) V13795 (shen.copy-vector-stage-1 1 V13791 V13792 (+ 1 V13793))))

(defun shen.copy-vector-stage-1 (V13803 V13804 V13805 V13806) (cond ((= V13806 V13803) V13805) (true (shen.copy-vector-stage-1 (+ 1 V13803) V13804 (address-> V13805 V13803 (<-address V13804 V13803)) V13806))))

(defun shen.copy-vector-stage-2 (V13814 V13815 V13816 V13817) (cond ((= V13815 V13814) V13817) (true (shen.copy-vector-stage-2 (+ V13814 1) V13815 V13816 (address-> V13817 V13814 V13816)))))

(defun shen.mk-pvar (V13819) (address-> (address-> (absvector 2) 0 shen.pvar) 1 V13819))

(defun shen.pvar? (V13821) (trap-error (and (absvector? V13821) (= (<-address V13821 0) shen.pvar)) (lambda E false)))

(defun shen.bindv (V13825 V13826 V13827) (let Vector (<-address (value shen.*prologvectors*) V13827) (address-> Vector (<-address V13825 1) V13826)))

(defun shen.unbindv (V13830 V13831) (let Vector (<-address (value shen.*prologvectors*) V13831) (address-> Vector (<-address V13830 1) shen.-null-)))

(defun shen.incinfs () (set shen.*infs* (+ 1 (value shen.*infs*))))

(defun shen.call_the_continuation (V13835 V13836 V13837) (cond ((and (cons? V13835) (and (cons? (hd V13835)) (= () (tl V13835)))) (cons (hd (hd V13835)) (append (tl (hd V13835)) (cons V13836 (cons V13837 ()))))) ((and (cons? V13835) (cons? (hd V13835))) (let NewContinuation (shen.newcontinuation (tl V13835) V13836 V13837) (cons (hd (hd V13835)) (append (tl (hd V13835)) (cons V13836 (cons NewContinuation ())))))) (true (shen.f_error shen.call_the_continuation))))

(defun shen.newcontinuation (V13841 V13842 V13843) (cond ((= () V13841) V13843) ((and (cons? V13841) (cons? (hd V13841))) (cons freeze (cons (cons (hd (hd V13841)) (append (tl (hd V13841)) (cons V13842 (cons (shen.newcontinuation (tl V13841) V13842 V13843) ())))) ()))) (true (shen.f_error shen.newcontinuation))))

(defun return (V13851 V13852 V13853) (shen.deref V13851 V13852))

(defun shen.measure&return (V13861 V13862 V13863) (do (shen.prhush (shen.app (value shen.*infs*) " inferences
" shen.a) (stoutput)) (shen.deref V13861 V13862)))

(defun unify (V13868 V13869 V13870 V13871) (shen.lzy= (shen.lazyderef V13868 V13870) (shen.lazyderef V13869 V13870) V13870 V13871))

(defun shen.lzy= (V13893 V13894 V13895 V13896) (cond ((= V13894 V13893) (thaw V13896)) ((shen.pvar? V13893) (bind V13893 V13894 V13895 V13896)) ((shen.pvar? V13894) (bind V13894 V13893 V13895 V13896)) ((and (cons? V13893) (cons? V13894)) (shen.lzy= (shen.lazyderef (hd V13893) V13895) (shen.lazyderef (hd V13894) V13895) V13895 (freeze (shen.lzy= (shen.lazyderef (tl V13893) V13895) (shen.lazyderef (tl V13894) V13895) V13895 V13896)))) (true false)))

(defun shen.deref (V13899 V13900) (cond ((cons? V13899) (cons (shen.deref (hd V13899) V13900) (shen.deref (tl V13899) V13900))) (true (if (shen.pvar? V13899) (let Value (shen.valvector V13899 V13900) (if (= Value shen.-null-) V13899 (shen.deref Value V13900))) V13899))))

(defun shen.lazyderef (V13903 V13904) (if (shen.pvar? V13903) (let Value (shen.valvector V13903 V13904) (if (= Value shen.-null-) V13903 (shen.lazyderef Value V13904))) V13903))

(defun shen.valvector (V13907 V13908) (<-address (<-address (value shen.*prologvectors*) V13908) (<-address V13907 1)))

(defun unify! (V13913 V13914 V13915 V13916) (shen.lzy=! (shen.lazyderef V13913 V13915) (shen.lazyderef V13914 V13915) V13915 V13916))

(defun shen.lzy=! (V13938 V13939 V13940 V13941) (cond ((= V13939 V13938) (thaw V13941)) ((and (shen.pvar? V13938) (not (shen.occurs? V13938 (shen.deref V13939 V13940)))) (bind V13938 V13939 V13940 V13941)) ((and (shen.pvar? V13939) (not (shen.occurs? V13939 (shen.deref V13938 V13940)))) (bind V13939 V13938 V13940 V13941)) ((and (cons? V13938) (cons? V13939)) (shen.lzy=! (shen.lazyderef (hd V13938) V13940) (shen.lazyderef (hd V13939) V13940) V13940 (freeze (shen.lzy=! (shen.lazyderef (tl V13938) V13940) (shen.lazyderef (tl V13939) V13940) V13940 V13941)))) (true false)))

(defun shen.occurs? (V13953 V13954) (cond ((= V13954 V13953) true) ((cons? V13954) (or (shen.occurs? V13953 (hd V13954)) (shen.occurs? V13953 (tl V13954)))) (true false)))

(defun identical (V13959 V13960 V13961 V13962) (shen.lzy== (shen.lazyderef V13959 V13961) (shen.lazyderef V13960 V13961) V13961 V13962))

(defun shen.lzy== (V13984 V13985 V13986 V13987) (cond ((= V13985 V13984) (thaw V13987)) ((and (cons? V13984) (cons? V13985)) (shen.lzy== (shen.lazyderef (hd V13984) V13986) (shen.lazyderef (hd V13985) V13986) V13986 (freeze (shen.lzy== (tl V13984) (tl V13985) V13986 V13987)))) (true false)))

(defun shen.pvar (V13989) (cn "Var" (shen.app (<-address V13989 1) "" shen.a)))

(defun bind (V13994 V13995 V13996 V13997) (do (shen.bindv V13994 V13995 V13996) (let Result (thaw V13997) (do (shen.unbindv V13994 V13996) Result))))

(defun fwhen (V14015 V14016 V14017) (cond ((= true V14015) (thaw V14017)) ((= false V14015) false) (true (simple-error (cn "fwhen expects a boolean: not " (shen.app V14015 "%" shen.s))))))

(defun call (V14033 V14034 V14035) (cond ((cons? V14033) (shen.call-help (function (shen.lazyderef (hd V14033) V14034)) (tl V14033) V14034 V14035)) (true false)))

(defun shen.call-help (V14040 V14041 V14042 V14043) (cond ((= () V14041) (V14040 V14042 V14043)) ((cons? V14041) (shen.call-help (V14040 (hd V14041)) (tl V14041) V14042 V14043)) (true (shen.f_error shen.call-help))))

(defun shen.intprolog (V14045) (cond ((and (cons? V14045) (cons? (hd V14045))) (let ProcessN (shen.start-new-prolog-process) (shen.intprolog-help (hd (hd V14045)) (shen.insert-prolog-variables (cons (tl (hd V14045)) (cons (tl V14045) ())) ProcessN) ProcessN))) (true (shen.f_error shen.intprolog))))

(defun shen.intprolog-help (V14049 V14050 V14051) (cond ((and (cons? V14050) (and (cons? (tl V14050)) (= () (tl (tl V14050))))) (shen.intprolog-help-help V14049 (hd V14050) (hd (tl V14050)) V14051)) (true (shen.f_error shen.intprolog-help))))

(defun shen.intprolog-help-help (V14056 V14057 V14058 V14059) (cond ((= () V14057) (V14056 V14059 (freeze (shen.call-rest V14058 V14059)))) ((cons? V14057) (shen.intprolog-help-help (V14056 (hd V14057)) (tl V14057) V14058 V14059)) (true (shen.f_error shen.intprolog-help-help))))

(defun shen.call-rest (V14064 V14065) (cond ((= () V14064) true) ((and (cons? V14064) (and (cons? (hd V14064)) (cons? (tl (hd V14064))))) (shen.call-rest (cons (cons ((hd (hd V14064)) (hd (tl (hd V14064)))) (tl (tl (hd V14064)))) (tl V14064)) V14065)) ((and (cons? V14064) (and (cons? (hd V14064)) (= () (tl (hd V14064))))) ((hd (hd V14064)) V14065 (freeze (shen.call-rest (tl V14064) V14065)))) (true (shen.f_error shen.call-rest))))

(defun shen.start-new-prolog-process () (let IncrementProcessCounter (set shen.*process-counter* (+ 1 (value shen.*process-counter*))) (shen.initialise-prolog IncrementProcessCounter)))

(defun shen.insert-prolog-variables (V14068 V14069) (shen.insert-prolog-variables-help V14068 (shen.flatten V14068) V14069))

(defun shen.insert-prolog-variables-help (V14077 V14078 V14079) (cond ((= () V14078) V14077) ((and (cons? V14078) (variable? (hd V14078))) (let V (shen.newpv V14079) (let XV/Y (subst V (hd V14078) V14077) (let Z-Y (remove (hd V14078) (tl V14078)) (shen.insert-prolog-variables-help XV/Y Z-Y V14079))))) ((cons? V14078) (shen.insert-prolog-variables-help V14077 (tl V14078) V14079)) (true (shen.f_error shen.insert-prolog-variables-help))))

(defun shen.initialise-prolog (V14081) (let Vector (address-> (value shen.*prologvectors*) V14081 (shen.fillvector (vector 10) 1 10 shen.-null-)) (let Counter (address-> (value shen.*varcounter*) V14081 1) V14081)))



